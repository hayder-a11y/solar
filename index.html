<!DOCTYPE html>
<html>

<head>
	<title>Solar System</title>
	<meta charset="utf-8">

	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			color: #ffffff;
			padding: 5px;
			font-family: Monospace;
			font-size: 13px;
			text-align: right;
		}
	</style>

	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/GLTFLoader.js"></script>
	<script src="js/CSS2DRenderer.js"></script>
	<script src="js/dat.gui.min.js"></script>

</head>

<body>

	<script>


		var scene = new THREE.Scene();
		scene2 = new THREE.Scene();


		var Stats;
		var innerw, height;
		var stars = [];

		var guic, controlConfig = {
			freezState: false,
			revolveSpeed: 24
		};

		var marker, spline;
		var matrix = new THREE.Matrix4();
		var up = new THREE.Vector3(0, 1, 0);
		var axis = new THREE.Vector3();

		var mercpath, venpath, earthpath, marspath, juppath, satpath, urapath, neppath;

		var planobj = [];
		var pathobj = [];

		var mt = vet = eat = mat = jupt = satt = urat = nept = 0;


		function Ellipse(xRadius, yRadius) {
			THREE.Curve.call(this);

			this.xRadius = xRadius;
			this.yRadius = yRadius;
		}

		Ellipse.prototype = Object.create(THREE.Curve.prototype);
		Ellipse.prototype.constructor = Ellipse;


		Ellipse.prototype.getPoint = function (t) {

			var radians = 2 * Math.PI * t;

			return new THREE.Vector3(this.xRadius * Math.cos(radians),
				0,
				this.yRadius * Math.sin(radians));

		};



		var camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 1, 20000);
		camera.position.set(10, 30, 100);


		var renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setClearColor(0x000000);
		renderer.setSize(window.innerWidth, window.innerHeight);

		innerw = window.innerWidth;
		height = window.innerHeight;

		document.body.appendChild(renderer.domElement);


	
		var controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.minDistance = 10;
		controls.maxDistance = 500;
		
	
		var ambientLight = new THREE.AmbientLight(0xffffff);
		scene.add(ambientLight);


		var directionalLight = new THREE.DirectionalLight(0xffffff);
		directionalLight.position.set(0, 1, 1).normalize();
		scene.add(directionalLight);


		
		function addSphere() {
			 
			for (var z = -1000; z < 1000; z += 20) {
				 
				var geometry = new THREE.SphereGeometry(0.5, 32, 32)
				var material = new THREE.MeshBasicMaterial({ color: 0xffffff });
				var sphere = new THREE.Mesh(geometry, material)
				
				sphere.position.x = Math.random() * innerw - Math.random() * innerw * 2;
				sphere.position.y = Math.random() * height - Math.random() * height * 2;
				
				sphere.position.z = z;
				
				sphere.scale.x = sphere.scale.y = 1;
				
				scene.add(sphere);
				
				stars.push(sphere);
			}
		}
		function animateStars() {

			
			for (var i = 0; i < stars.length; i++) {
				star = stars[i];
			 
				star.position.z += i / 10;
				
				if (star.position.z > 2000) star.position.z -= 3000;

			}

		}

		var pathSegments = 128;
		var tubeRadius = 0.03;
		var radiusSegments = 3;
		var closed = true;

		var material = new THREE.MeshPhongMaterial({
			color: 'white',
		});

		
		mercpath = new Ellipse(15, 10);
		var mercgeometry = new THREE.TubeBufferGeometry(mercpath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(mercgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);

		venpath = new Ellipse(22, 15);
		var venusgeometry = new THREE.TubeBufferGeometry(venpath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(venusgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
		
		earthpath = new Ellipse(28, 22);
		var earthgeometry = new THREE.TubeBufferGeometry(earthpath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(earthgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
		

		marspath = new Ellipse(35, 28);
		var marsgeometry = new THREE.TubeBufferGeometry(marspath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(marsgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
	
		juppath = new Ellipse(46, 34);
		var jupgeometry = new THREE.TubeBufferGeometry(juppath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(jupgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
		
		satpath = new Ellipse(57, 42);
		var satgeometry = new THREE.TubeBufferGeometry(satpath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(satgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
	
		urapath = new Ellipse(69, 49);
		var urageometry = new THREE.TubeBufferGeometry(urapath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(urageometry, material);
		scene.add(mesh);
		pathobj.push(mesh);
		
		neppath = new Ellipse(79, 59);
		var nepgeometry = new THREE.TubeBufferGeometry(neppath, pathSegments, tubeRadius, radiusSegments, closed);
		mesh = new THREE.Mesh(nepgeometry, material);
		scene.add(mesh);
		pathobj.push(mesh);


		
		var loader = new THREE.GLTFLoader();
		
		var sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune;



		loader.load('model/sun/sun.gltf', function (gltf) {         
			sun = gltf.scene;
			gltf.scene.scale.set(18, 18, 18);
			gltf.scene.position.x = 0;				    
			gltf.scene.position.y = -2;				 
			gltf.scene.position.z = -3;				   
		
			scene.add(gltf.scene);
			planobj.push(sun);
		});

		loader.load('model/mercury/mercury.gltf', function (gltf) {         
			mercury = gltf.scene;
			gltf.scene.scale.set(2, 2, 2);
			var pt = mercpath.getPoint(mt);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(mercury);
		});

		loader.load('model/venus/venus.gltf', function (gltf) {           
			venus = gltf.scene;
			gltf.scene.scale.set(2, 2, 2);
			var pt = venpath.getPoint(vet);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(venus);
		});

		loader.load('model/earth/earth.gltf', function (gltf) {        
			earth = gltf.scene;
			gltf.scene.scale.set(2, 2, 2);
			var pt = earthpath.getPoint(eat);
			moonorbit = earthpath.getPoint(eat);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(earth);
		});

		loader.load('model/mars/mars.gltf', function (gltf) {           
			mars = gltf.scene;
			gltf.scene.scale.set(2, 2, 2);
			var pt = marspath.getPoint(mat);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(mars);
		});

		loader.load('model/jupiter/jupiter.gltf', function (gltf) {        
			jupiter = gltf.scene;
			gltf.scene.scale.set(8, 8, 8);
			var pt = juppath.getPoint(jupt);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(jupiter);
		});


		loader.load('model/saturn/saturn.gltf', function (gltf) {        
			saturn = gltf.scene;
			gltf.scene.scale.set(7, 7, 7);
			var pt = satpath.getPoint(satt);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(saturn);
		});

		loader.load('model/uranus/uranus.gltf', function (gltf) {          
			uranus = gltf.scene;
			gltf.scene.scale.set(3, 3, 3);
			var pt = urapath.getPoint(urat);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(uranus);
		});

		loader.load('model/neptune/neptune.gltf', function (gltf) {         
			neptune = gltf.scene;
			gltf.scene.scale.set(3, 3, 3);
			var pt = neppath.getPoint(nept);
			gltf.scene.position.set(pt.x, pt.y, pt.z);
			scene.add(gltf.scene);
			planobj.push(neptune);
		});




		guic = new dat.GUI({ width: 350 });
		
		var controlGUI = guic.addFolder("Controls");
		
		controlGUI.add(controlConfig, 'freezState')

		controlGUI.add(controlConfig, 'revolveSpeed', 1, 24).onChange(function () {
			});

	
		function animate() {
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			
			animateStars();
			

			if (!controlConfig.freezState)
				revolvePlanet();
			console.log(controlConfig.revolveSpeed);

		}


		function revolvePlanet() {
			
			if (mercury) { 	//mercury.rotation.y+=0.05;
				var pt = mercpath.getPoint(mt);
				var tangent = mercpath.getTangent(mt).normalize();
				mercury.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				mt = (mt >= 1) ? 0 : mt += (0.005 / controlConfig.revolveSpeed);
			}
			if (venus) {
				//venus.rotation.y+=0.04;
				var pt = venpath.getPoint(vet);
				var tangent = venpath.getTangent(vet).normalize();
				venus.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				vet = (vet >= 1) ? 0 : vet += 0.001 / controlConfig.revolveSpeed;
			}
			if (earth) {
				earth.rotation.y += 0.02;
				var pt = earthpath.getPoint(eat);
				var tangent = earthpath.getTangent(eat).normalize();
				earth.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				eat = (eat >= 1) ? 0 : eat += 0.0003 / controlConfig.revolveSpeed;
			}
		
			if (mars) {	//mars.rotation.z+=0.02;
				var pt = marspath.getPoint(mat);
				var tangent = marspath.getTangent(mat);
				mars.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				mat = (mat >= 1) ? 0 : mat += 0.0001 / controlConfig.revolveSpeed;
			}
			if (jupiter) {
				jupiter.rotation.y += 0.004;
				var pt = juppath.getPoint(jupt);
				var tangent = juppath.getTangent(jupt).normalize();
				jupiter.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				jupt = (jupt >= 1) ? 0 : jupt += 0.00006 / controlConfig.revolveSpeed;
			}
			if (saturn) {
				saturn.rotation.y += 0.009;
				var pt = satpath.getPoint(satt);
				var tangent = satpath.getTangent(satt).normalize();
				saturn.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				satt = (satt >= 1) ? 0 : satt += 0.00003 / controlConfig.revolveSpeed;
			}
			if (uranus) {
				uranus.rotation.y += 0.0004;
				var pt = urapath.getPoint(urat);
				var tangent = urapath.getTangent(urat).normalize();
				uranus.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				urat = (urat >= 1) ? 0 : urat += 0.000009 / controlConfig.revolveSpeed;
			}
			if (neptune) {
				neptune.rotation.y += 0.0004;
				var pt = neppath.getPoint(nept);
				var tangent = neppath.getTangent(nept).normalize();
				neptune.position.set(pt.x, pt.y, pt.z);
				// calculate the axis to rotate around
				axis.crossVectors(up, tangent).normalize();
				// calcluate the angle between the up vector and the tangent
				var radians = Math.acos(up.dot(tangent));
				nept = (nept >= 1) ? 0 : nept += 0.0000009 / controlConfig.revolveSpeed;
			}


		}
		addSphere();
		animate();

	</script>
</body>

</html>